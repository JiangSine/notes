# 线程池

## 1. 线程池的使用

### 1.1 为什么使用线程池
**创建/销毁线程伴随着系统开销，过于频繁的创建/销毁线程，会很大程度上影响处理效率。**

我们使用网上经常可以看到的例子：

假设一个服务器完成一项任务所需时间为：`T1`创建线程时间，`T2`在线程中执行任务的时间，`T3`销毁线程时间。
如果：`T1 + T3`远大于`T2`，则可以采用线程池，以提高服务器性能。

**线程并发数量过多，抢占系统资源从而导致阻塞。**

要知道线程能共享系统资源，如果同时执行的线程过多，就有可能导致系统资源不足而产生阻塞的情况。

运用线程池能有效的控制线程最大并发数，避免以上的问题。

**对线程进行一些简单的管理。**
比如：延时执行、定时循环执行的策略等。

其实这里运用的是线程池本身的高级特性，运用线程池都能进行很好的实现。虽然不是用线程池，本身也可以通过其他方式实现这些管理。

### 1.2 线程池的技术概括

**一个线程池包括以下四个基本组成部分：**

1. 线程池管理器(ThreadPool): 用于创建并管理线程池，包括创建线程池，销毁线程池，添加新任务；
2. 工作线程(PoolWorker): 线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
3. 任务接口(Task): 每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；
4. 任务队列(taskQueue): 用于存放没有处理的任务。提供一种缓冲机制。

线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。

同时，线程池可以做到，使线程达到复用的目的， 执行完一个任务之后，并不被销毁，而是可以继续执行其他的任务。

### 1.3 JDK中提供的线程池技术

#### 1.3.1 ThreadPoolExecutor

#####  创建一个ThreadPoolExecutor
首先我们可以看一下`ThreadPoolExecutor`的构造方法。

```Java
public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,Executors.defaultThreadFactory(), defaultHandler);
}

public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,threadFactory, defaultHandler);
}


public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,RejectedExecutionHandler handler) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,Executors.defaultThreadFactory(), handler);
}
/**
 * Creates a new ThreadPoolExecutor with the given initial parameters.
 * Parameters:
 * corePoolSize - the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set
 * maximumPoolSize - the maximum number of threads to allow in the pool
 * keepAliveTime - when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.
 * unit - the time unit for the keepAliveTime argument
 * workQueue - the queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method.
 * threadFactory - the factory to use when the executor creates a new thread
 * handler - the handler to use when execution is blocked because the thread bounds and queue capacities are reached
*/

public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,RejectedExecutionHandler handler) {
    if (corePoolSize < 0 ||maximumPoolSize <= 0 ||maximumPoolSize < corePoolSize ||keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```
初始化一个线程池，需要不同的参数去初始化，

**`int corePoolSize` -> 该线程池中核心线程数最大值**

核心线程：

线程池新建线程的时候，如果当前线程总数小于`corePoolSize`，则新建的是核心线程，如果超过`corePoolSize`，则新建的是非核心线程。
核心线程默认情况下会一直存活在线程池中，即使这个核心线程啥也不干(闲置状态)。

如果指定`ThreadPoolExecutor`的`allowCoreThreadTimeOut`这个属性为`true`，那么核心线程如果不干活(闲置状态)的话，超过一定时间(时长下面参数决定)，就会被销毁掉。

**`int maximumPoolSize` -> 该线程池中线程总数最大值**

线程总数 = 核心线程数 + 非核心线程数。核心线程在上面解释过了，这里说下非核心线程：
不是核心线程的线程。

**`long keepAliveTime` -> 该线程池中非核心线程闲置超时时长**

一个非核心线程，如果不干活(闲置状态)的时长超过这个参数所设定的时长，就会被销毁掉。

如果设置`allowCoreThreadTimeOut = true`，则会作用于核心线程。

**`TimeUnit unit` -> keepAliveTime的单位**

`keepAliveTime`的单位，`TimeUnit`是一个枚举类型，其包括：
`NANOSECONDS`，`MICROSECONDS`，`MILLISECONDS`，`SECONDS`，`MINUTES`，`HOURS`，`DAYS`。

**`BlockingQueue<Runnable> workQueue` -> 该线程池中的任务队列**
该线程池中的任务队列：维护着等待执行的`Runnable`对象

当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务

常用的`workQueue`类型：

- `SynchronousQueue`：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现<线程数达到了`maximumPoolSize`而不能新建线程>的错误，使用这个类型队列的时候，`maximumPoolSize`一般指定成`Integer.MAX_VALUE`，即无限大。

  一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。


- `LinkedBlockingQueue`：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了`maximumPoolSize`的设定失效，因为总线程数永远不会超过`corePoolSize`。

  一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。

- `ArrayBlockingQueue`：可以限定队列的长度，接收到任务的时候，如果没有达到`corePoolSize`的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了`maximumPoolSize`，并且队列也满了，则发生错误。

  是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。

- `DelayQueue`：队列内元素必须实现`Delayed`接口，这就意味着你传进去的任务必须先实现`Delayed`接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务。

  一个具有优先级得无限阻塞队列。

**`ThreadFactory threadFactory` -> 创建线程的方式**

默认使用Executors内部类DefaultThreadFactory，可以通过实现ThreadFactory接口，写自己的Factory，通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug和定位问题时非常又帮助；

**`RejectedExecutionHandler handler` -> 饱和策略**

当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。

当拒绝处理任务时的策略，有以下四种取值：
```Java
ThreadPoolExecutor.AbortPolicy;//丢弃任务并抛出RejectedExecutionException异常。
ThreadPoolExecutor.DiscardPolicy;//也是丢弃任务，但是不抛出异常。
ThreadPoolExecutor.DiscardOldestPolicy;//丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy;//由调用线程处理该任务
//当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。
```

##### 向ThreadPoolExecutor添加任务
通过`ThreadPoolExecutor.execute(Runnable command)`或者`AbstractExecutorService.<T> Future<T> submit(Callable<T> task)`方法即可向线程池内添加一个任务。

`execute()`方法实际上是`Executor`中声明的方法，在`ThreadPoolExecutor`进行了具体的实现，这个方法是`ThreadPoolExecutor`的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。

`submit()`方法是在`ExecutorService`中声明的方法，在`AbstractExecutorService`就已经有了具体的实现，在`ThreadPoolExecutor`中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和`execute()`方法不同，它能够返回任务执行的结果，去看`submit()`方法的实现，会发现它实际上还是调用的`execute()`方法，只不过它利用了`Future`来获取任务执行结果。

##### ThreadPoolExecutor的策略
上面介绍参数的时候其实已经说到了ThreadPoolExecutor执行的策略，这里给总结一下，当一个任务被添加进线程池时：

1. 线程数量未达到corePoolSize，则新建一个线程(核心线程)执行任务
2. 线程数量达到了corePools，则将任务移入队列等待
3. 队列已满，新建线程(非核心线程)执行任务
4. 队列已满，总线程数又达到了maximumPoolSize，就会由`RejectedExecutionHandler`抛出异常

#### 1.3.2 常见四种线程池的创建方式。




## 2. 源码分析

### 2.1 变量讲述

#### 2.1.1 ctl
它记录了当前线程池的运行状态和线程池内的线程数；一个变量是怎么记录两个值的呢？它是一个AtomicInteger 类型，有32个字节，这个32个字节中，高3位用来标识线程池的运行状态，低29位用来标识线程池内当前存在的线程数；

```Java
/**
 * The main pool control state, ctl, is an atomic integer packing
 * two conceptual fields
 *   workerCount, indicating the effective number of threads
 *   runState,    indicating whether running, shutting down etc
 *
 * In order to pack them into one int, we limit workerCount to
 * (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2
 * billion) otherwise representable. If this is ever an issue in
 * the future, the variable can be changed to be an AtomicLong,
 * and the shift/mask constants below adjusted. But until the need
 * arises, this code is a bit faster and simpler using an int.
 *
 * The workerCount is the number of workers that have been
 * permitted to start and not permitted to stop.  The value may be
 * transiently different from the actual number of live threads,
 * for example when a ThreadFactory fails to create a thread when
 * asked, and when exiting threads are still performing
 * bookkeeping before terminating. The user-visible pool size is
 * reported as the current size of the workers set.
 *
 * The runState provides the main lifecycle control, taking on values:
 *
 *   RUNNING:  Accept new tasks and process queued tasks
 *   SHUTDOWN: Don't accept new tasks, but process queued tasks
 *   STOP:     Don't accept new tasks, don't process queued tasks,
 *             and interrupt in-progress tasks
 *   TIDYING:  All tasks have terminated, workerCount is zero,
 *             the thread transitioning to state TIDYING
 *             will run the terminated() hook method
 *   TERMINATED: terminated() has completed
 *
 * The numerical order among these values matters, to allow
 * ordered comparisons. The runState monotonically increases over
 * time, but need not hit each state. The transitions are:
 *
 * RUNNING -> SHUTDOWN
 *    On invocation of shutdown(), perhaps implicitly in finalize()
 * (RUNNING or SHUTDOWN) -> STOP
 *    On invocation of shutdownNow()
 * SHUTDOWN -> TIDYING
 *    When both queue and pool are empty
 * STOP -> TIDYING
 *    When pool is empty
 * TIDYING -> TERMINATED
 *    When the terminated() hook method has completed
 *
 * Threads waiting in awaitTermination() will return when the
 * state reaches TERMINATED.
 *
 * Detecting the transition from SHUTDOWN to TIDYING is less
 * straightforward than you'd like because the queue may become
 * empty after non-empty and vice versa during SHUTDOWN state, but
 * we can only terminate if, after seeing that it is empty, we see
 * that workerCount is 0 (which sometimes entails a recheck -- see
 * below).
 */
//利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态：
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));   
```
通过注释，本身就说明了很多。
##### 线程池状态
线程池有5种状态，这五种状态由五个静态常量标识，每种状态的值的大小

```Java
//32-3 = 29 ，低位29位存储线程池中线程数
private static final int COUNT_BITS = Integer.SIZE - 3;   
//线程池最多可以有536870911个线程，一般绝对创建不到这么大
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

//RUNNING线程池能接受新任务（只有running状态才会接收新任务），并且可以运行队列中的任务
//-1的二进制为32个1，移位后为：11100000000000000000000000000000
private static final int RUNNING = -1 << COUNT_BITS;

//SHUTDOWN不再接受新任务，但仍可以执行队列中的任务
//0的二进制为32个0，移位后还是全0
private static final int SHUTDOWN = 0 << COUNT_BITS;

//STOP不再接受新任务，不再执行队列中的任务，而且要中断正在处理的任务
//1的二进制为前面31个0，最后一个1，移位后为：00100000000000000000000000000000
private static final int STOP = 1 << COUNT_BITS;

//TIDYING所有任务均已终止，workerCount的值为0，转到TIDYING状态的线程即将要执行terminated()钩子方法.
//2的二进制为01000000000000000000000000000000
private static final int TIDYING = 2 << COUNT_BITS;

//TERMINATED terminated()方法执行结束.
//3移位后01100000000000000000000000000000
private static final int TERMINATED = 3 << COUNT_BITS;
```
**需要知道的是:**
> 1. 只有RUNNING状态下才会接收新任务；
> 2. 只有RUNNING状态和SHUTDOWN状态才会执行任务队列中的任务；
> 3. 其它状态都不会接收新任务，不会执行任务队列中的任务；

**线程池之间的状态的转换如下：**
- **`RUNNING -> SHUTDOWN`**:调用了`shutdown`方法，线程池实现了`finalize`方法，在里面调用了`shutdown`方法，因此`shutdown`可能是在`finalize`中被隐式调用的
- **`(RUNNING or SHUTDOWN) -> STOP`**: 调用了`shutdownNow`方法
- **`SHUTDOWN -> TIDYING`**: 当队列和线程池均为空的时候
- **`STOP -> TIDYING`**: 当线程池为空的时候
- **`TIDYING -> TERMINATED`**: 处于`TIDYING`状态后最终会进入`TERMINATED`状态

**与ctl相关的三个方法:**

```Java
/获取线程池的状态,也就是将ctl低29位都置为0后的值
private static int runStateOf(int c)     { return c & ~CAPACITY; }
//获取线程池中线程数，也就是ctl低29位的值
private static int workerCountOf(int c)  { return c & CAPACITY; }  
//设置ctl的值，rs为线程池状态，wc为线程数；
private static int ctlOf(int rs, int wc) { return rs | wc; }     
```

#### 2.1.2 workers

```Java
/**
 * Set containing all worker threads in pool. Accessed only when
 * holding mainLock.
 * 用来存储线程池中的线程，线程都被封装成了Worker对象
 */
private final HashSet<Worker> workers = new HashSet<Worker>();
```

### 2.2 方法讲述























## 自带的各种坑

#### 1. `Executors.newFixedThreadPool(10)`

```Java
new ThreadPoolExecutor(10, 10, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
```
初始化一个指定线程数的线程池，其中`corePoolSize == maximumPoolSize`，使用`LinkedBlockingQuene`作为阻塞队列，超时时间为0，当线程池没有可执行任务时，也不会释放线程。
因为队列`LinkedBlockingQueue`大小为默认的`Integer.MAX_VALUE`，可以无限的往里面添加任务，直到内存溢出。

#### 2. `Executors.newCachedThreadPool()`

```Java
new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue<Runnable>());
```
初始化一个可以缓存线程的线程池，默认超时时间60s，线程池的最小线程数时0，但是最大线程数为`Integer.MAX_VALUE`，即2147483647，内部使用`SynchronousQueue`作为阻塞队列。

因为线程池的最大值了`Integer.MAX_VALUE`，会导致无限创建线程；所以，使用该线程池时，一定要注意控制并发的任务数，如果短时有大量任务要执行，就会创建大量的线程，导致严重的性能问题（线程上下文切换带来的开销），线程创建占用堆外内存，如果任务对象也不小，它就会使堆外内存和堆内内存其中的一个先耗尽，导致`OOM`。

#### 3. `Executors.newSingleThreadExecutor()`
```Java
new FinalizableDelegatedExecutorService(
    new ThreadPoolExecutor(1, 1,0L,
                        TimeUnit.MILLISECONDS,
                        new LinkedBlockingQueue<Runnable>()
                        )
);
```
同`newFixedThreadPool`线程池一样，队列用的是`LinkedBlockingQueue`，队列大小为默认的`Integer.MAX_VALUE`，可以无限的往里面添加任务，直到内存溢出。






```Java

```





```Java

```

```Java

```

```Java

```

```Java

```
